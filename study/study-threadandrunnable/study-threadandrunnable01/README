Runnable和Thread的关系和区别
    Runnable方式可以避免Thread方式由于java单继承特性带来的缺陷
    Runnable的代码可以被多个线程Thread共享，适合于多个线程同时处理同一个资源的情况

线程的生命周期
创建 - （就绪状态 ， 阻塞状态 ， 运行状态）终止

    运行状态：处于就绪状态的线程， 一旦获取了cpu资源， 便进入到运行状态， 开始执行run（）方法中的逻辑
    终止：线程的run()方法执行完毕， 或者是线程调用来stop()方法， 线程便进入终止状态
    阻塞状态：一个正在执行的线程在某些状态下， 由于某种原因暂时让出cpu资源， 暂停了自己的执行， 便进入了阻塞状态， 如调用了sleep()方法

守护线程：
    注意事项：
        > setDaemon(true）必须在start()方法之前调用， 否则会抛出IllegaithreadStateException异常
        > 在守护线程中产生的新线程也是守护线程
        > 不是所有的任务都开源分配给守护线程来执行， 比如读写操作或者计算逻辑
=======================
example01
    Runnable和Thread创建线程的方式

example02
    使用Thread模拟火车站卖票

example03
    使用runnable接口进行火车票的模拟

example04
    守护线程与主线程案例， 守护进程进行想文件中写东西， 等用户线程关闭后， 守护线程也关闭。但是守护线程并没关闭


